# 백준 1083번 소트
### 2023.03.31
### https://www.acmicpc.net/problem/1083
### 유형 : 정렬, 그리디 알고리즘
### Gold 5

> **문제**
>  크기가 N인 배열 A가 있다. 배열에 있는 모든 수는 서로 다르다. 이 배열을 소트할 때, 연속된 두 개의 원소만 교환할 수 있다. 그리고, 교환은 많아봐야 S번 할 수 있다. 이때, 소트한 결과가 사전순으로 가장 뒷서는 것을 출력한다.


> **입력**
> 첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 각 원소가 차례대로 주어진다. 이 값은 1000000보다 작거나 같은 자연수이다. 마지막 줄에는 S가 주어진다. S는 1000000보다 작거나 같은 음이 아닌 정수이다.

> **출력**
> 첫째 줄에 문제의 정답을 출력한다.

해당 문제는 **사전순**이라는 말을 잘 해석해야 한다.
무작정 버블정렬로 정렬하는 문제가 아닌, 옮길 수 있는 **최댓값**을 먼저 옮기는 것이 목적이다.

예를 들어, 정렬하고자 하는 배열이 [10, 20, 30, 40, 50, 60, 70]일 때 
S에 따른 결과값이 다음과 같아야 한다.
```
- S = 0
[10, 20, 30, 40, 50, 60, 70]

- S = 1
[20, 10, 30, 40, 50, 60, 70]

- S = 2
[30, 10, 20, 40, 50, 60, 70]

- S = 3
[40, 10, 20, 30, 50, 60, 70]

- S = 4
[50, 10, 20, 30, 40, 60, 70]

- S = 5
[60, 10, 20, 30, 40, 50, 70]

- S = 6
[70, 10, 20, 30, 40, 50, 60]

- S = 8
[70, 20, 10, 30, 40, 50, 60]

- S = 9
[70, 30, 10, 20, 40, 50, 60]
```

문제의 해결 방법은 **그리디 알고리즘** 즉, 우선 최댓값을 먼저 찾아서 옮기는 것이다.
최댓값을 다 옮길 수 있을 만큼 S가 주어진다면, 최댓값을 최대한 앞으로 옮기면서 S를 줄여 나가면 된다.

```python
N = int(input())
arr = list(map(int, input().split(" ")))
S = int(input())

def print_arr(arr):
    print(" ".join(map(str, arr)))

save_arr = []

while True:
    try:
        if S == 0:
            break
        
        maxval, maxidx = max(arr), arr.index(max(arr))
        if S < maxidx:
            new_arr = arr[:S+1]
            maxval, maxidx = max(new_arr), new_arr.index(max(new_arr))
            save_arr.append(maxval)
        else:
            save_arr.append(maxval)
        
        arr.remove(maxval)
        S -= maxidx
    
    except Exception:
        break

save_arr.extend(arr)
    
print_arr(save_arr)
```

코드는 위와 같다. 
더 효율적으로 짤 수 있을 것 같지만 생각처럼 잘 되지 않는다.
