# 백준 2748번 피보나치 수 2
### 2023.04.03
### https://www.acmicpc.net/problem/2748
### 유형 : DP
### Bronze 1

> **문제**

피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.
이를 식으로 써보면 $F_n = F_{n-1} + F_{n-2} (n ≥ 2)$가 된다.
n=17일때 까지 피보나치 수를 써보면 다음과 같다.
$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597$

$n$ 이 주어졌을 때, $n$번째 피보나치 수를 구하는 프로그램을 작성하시오.

> **입력**

첫째 줄에 $n$이 주어진다. $n$은 90보다 작거나 같은 자연수이다.

> **출력**

첫째 줄에 $n$번째 피보나치 수를 출력한다.

```python
n = int(input())

dp = [0]*(n+1)
dp[1] = 1

for i in range(2, n+1):
    dp[i] = dp[i-2] + dp[i-1]

print(dp[-1])
```

dp 문제는 보통 n+1 크기의 dp라는 배열을 만들고 시작하는 것 같다.
피보나치 수는 $0, 1, 1, 2, 3, 5, \cdots$ 로 이어지기 때문에 `arr[0] = 0`, `arr[1] = 1`로 초기화를 한 후 시작한다.
dp는 연산을 줄이기 위하여 이전에 계산한 값을 dp배열에 저장해놓고, 또 사용할 일이 생기면 이전 연산은 생략하고 dp배열에 저장된 값을 가져다 사용한다.

위의 문제를 보면 `dp[2]`를 구하기 위해 `dp[0]`과 `dp[1]`에 있는 값을 가져다 사용한다.
동일하게 `dp[3]`을 구하기 위해서는 `dp[1]`과 `dp[2]`에 있는 값을 사용하여 계산한다.

이런식으로 Dynamic Programming은 이전에 계산한 값을 사용하여 연산횟수를 줄인다.
